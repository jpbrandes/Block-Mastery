<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2048 Pro</title>
    <style>
        :root {
            --bg-color: #faf8ef; --grid-bg: #bbada0; --cell-bg: #cdc1b4;
        }
        body {
            background: var(--bg-color); color: #776e65; font-family: sans-serif;
            display: flex; flex-direction: column; align-items: center; height: 100vh; margin: 0; justify-content: center;
        }
        .header { width: 320px; display: flex; justify-content: space-between; margin-bottom: 20px; }
        .score-container { background: #bbada0; padding: 10px; border-radius: 6px; color: white; min-width: 60px; text-align: center; }
        
        #game-container {
            position: relative; width: 320px; height: 320px;
            background: var(--grid-bg); border-radius: 6px; padding: 10px; box-sizing: border-box;
        }
        /* Células de fundo fixas */
        .grid-background {
            display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); gap: 10px;
            width: 100%; height: 100%;
        }
        .grid-cell { background: var(--cell-bg); border-radius: 3px; }

        /* Peças móveis */
        .tile {
            position: absolute; width: 67.5px; height: 67.5px;
            border-radius: 3px; display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 32px; transition: transform 0.1s ease-in-out;
            z-index: 10;
        }
        
        /* Cores das peças */
        .t2 { background: #eee4da; color: #776e65; }
        .t4 { background: #ede0c8; color: #776e65; }
        .t8 { background: #f2b179; color: white; }
        .t16 { background: #f59563; color: white; }
        .t32 { background: #f67c5f; color: white; }
        .t64 { background: #f65e3b; color: white; }
        .t128 { background: #edcf72; color: white; font-size: 24px; }
        .t256 { background: #edcc61; color: white; font-size: 24px; }
        .t512 { background: #edc850; color: white; font-size: 24px; }
        .t1024 { background: #edc53f; color: white; font-size: 20px; }
        .t2048 { background: #edc22e; color: white; font-size: 20px; box-shadow: 0 0 10px #f3d774; }

        .merged { animation: merge-pop 0.2s ease-in-out; }
        @keyframes merge-pop { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
        
        #overlay {
            position: absolute; inset: 0; background: rgba(238, 228, 218, 0.73);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; border-radius: 6px;
        }
        button { background: #8f7a66; color: white; border: none; padding: 10px 20px; border-radius: 3px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div class="header">
        <h1 style="margin:0">2048</h1>
        <div class="score-container">
            <div style="font-size: 10px">SCORE</div>
            <div id="score" style="font-size: 20px; font-weight: bold">0</div>
        </div>
    </div>

    <div id="game-container">
        <div class="grid-background" id="bg-grid"></div>
        <div id="overlay">
            <h2>Fim de Jogo!</h2>
            <button onclick="setupGame()">Reiniciar</button>
        </div>
    </div>

    <script>
        const container = document.getElementById('game-container');
        const scoreEl = document.getElementById('score');
        const overlay = document.getElementById('overlay');
        let board = [];
        let score = 0;
        const size = 4;
        const gap = 10;
        const tileSize = 67.5;

        function setupGame() {
            container.querySelectorAll('.tile').forEach(t => t.remove());
            board = Array(size * size).fill(null);
            score = 0;
            scoreEl.innerText = 0;
            overlay.style.display = 'none';
            initBg();
            addTile(); addTile();
        }

        function initBg() {
            const bg = document.getElementById('bg-grid');
            bg.innerHTML = '';
            for(let i=0; i<16; i++) bg.appendChild(document.createElement('div')).className = 'grid-cell';
        }

        class Tile {
            constructor(pos, val) {
                this.pos = pos;
                this.val = val;
                this.el = document.createElement('div');
                this.updateElement();
                container.appendChild(this.el);
            }
            updateElement() {
                this.el.className = `tile t${this.val}`;
                this.el.innerText = this.val;
                const x = (this.pos % size) * (tileSize + gap) + gap;
                const y = Math.floor(this.pos / size) * (tileSize + gap) + gap;
                this.el.style.transform = `translate(${x}px, ${y}px)`;
            }
            remove() { setTimeout(() => this.el.remove(), 100); }
        }

        function addTile() {
            const empty = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
            if (empty.length === 0) return;
            const pos = empty[Math.floor(Math.random() * empty.length)];
            const val = Math.random() < 0.9 ? 2 : 4;
            board[pos] = new Tile(pos, val);
        }

        function move(dir) {
            let moved = false;
            const isVertical = dir === 'up' || dir === 'down';
            const isReverse = dir === 'right' || dir === 'down';

            for (let i = 0; i < size; i++) {
                let line = [];
                for (let j = 0; j < size; j++) {
                    const idx = isVertical ? (i + j * size) : (i * size + j);
                    line.push(idx);
                }
                if (isReverse) line.reverse();

                const oldLine = line.map(idx => board[idx]);
                const newLine = processLine(oldLine);

                newLine.forEach((tile, index) => {
                    const targetIdx = line[index];
                    if (tile && (board[targetIdx] !== tile || targetIdx !== tile.pos)) {
                        board[targetIdx] = tile;
                        tile.pos = targetIdx;
                        tile.updateElement();
                        moved = true;
                    } else if (!tile) {
                        board[targetIdx] = null;
                    }
                });
            }

            if (moved) {
                setTimeout(() => {
                    addTile();
                    if (!canMove()) overlay.style.display = 'flex';
                }, 110);
            }
        }

        function processLine(line) {
            let filtered = line.filter(t => t !== null);
            let result = Array(size).fill(null);
            
            for (let i = 0; i < filtered.length; i++) {
                if (filtered[i] && filtered[i+1] && filtered[i].val === filtered[i+1].val) {
                    const combinedVal = filtered[i].val * 2;
                    score += combinedVal;
                    scoreEl.innerText = score;
                    
                    filtered[i].val = combinedVal;
                    filtered[i].el.classList.add('merged');
                    filtered[i+1].remove(); // Remove a duplicata
                    
                    result[i] = filtered[i];
                    filtered[i+1] = null;
                    i++;
                } else if (filtered[i]) {
                    result[i] = filtered[i];
                }
            }
            return result.filter(t => t !== null).concat(Array(size).fill(null)).slice(0, 4);
        }

        function canMove() {
            if (board.includes(null)) return true;
            for (let i = 0; i < 16; i++) {
                const x = i % 4, y = Math.floor(i / 4);
                if (x < 3 && board[i].val === board[i+1].val) return true;
                if (y < 3 && board[i].val === board[i+4].val) return true;
            }
            return false;
        }

        // Eventos
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') move('up');
            if (e.key === 'ArrowDown') move('down');
            if (e.key === 'ArrowLeft') move('left');
            if (e.key === 'ArrowRight') move('right');
        });

        // Touch Simplificado
        let tsX, tsY;
        document.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; tsY = e.touches[0].clientY; });
        document.addEventListener('touchend', e => {
            const dx = e.changedTouches[0].clientX - tsX, dy = e.changedTouches[0].clientY - tsY;
            if (Math.abs(dx) > Math.abs(dy)) { if(Math.abs(dx) > 30) move(dx > 0 ? 'right' : 'left'); }
            else { if(Math.abs(dy) > 30) move(dy > 0 ? 'down' : 'up'); }
        });

        setupGame();
    </script>
</body>
</html>
